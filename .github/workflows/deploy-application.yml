name: Simple Deployment Pipeline

on:
  push:
    branches:
      - main
    paths:
      - 'backend/**'
      - '.github/workflows/deploy-application.yml'

env:
  NODE_VERSION: '18'
  INSTANCE_IP: '44.194.207.22'

jobs:
  deploy:
    name: Deploy Application
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./backend
    steps:
      # Step 1: Check compile errors
      - name: 1ï¸âƒ£ Check Compile Errors
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: backend/package-lock.json

      - name: Install dependencies
        run: npm ci

      - name: TypeScript compile check
        run: |
          echo "ğŸ” Checking for TypeScript compile errors..."
          npm run typecheck
          echo "âœ… No compile errors found"

      # Step 2: Check linting issues
      - name: 2ï¸âƒ£ Check Linting Issues
        run: |
          echo "ğŸ” Checking for linting issues..."
          npm run lint
          echo "âœ… No linting issues found"

      # Step 3: Build
      - name: 3ï¸âƒ£ Build Application
        run: |
          echo "ğŸ—ï¸ Building application..."
          npm run build
          echo "âœ… Build completed successfully"

      # Configure AWS credentials for Systems Manager
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      # Get EC2 instance ID from IP address
      - name: Get EC2 Instance ID
        id: get-instance
        run: |
          echo "ğŸ” Finding EC2 instance ID for IP ${{ env.INSTANCE_IP }}..."
          
          # Try multiple methods to find the instance
          INSTANCE_ID=""
          
          # Method 1: Try with ip-address filter
          echo "Trying method 1: ip-address filter..."
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=instance-state-name,Values=running" \
                      "Name=ip-address,Values=${{ env.INSTANCE_IP }}" \
            --query 'Reservations[0].Instances[0].InstanceId' \
            --output text 2>/dev/null || echo "None")
          
          # Method 2: If that fails, try network-interface.association.public-ip
          if [ "$INSTANCE_ID" = "None" ] || [ "$INSTANCE_ID" = "null" ] || [ -z "$INSTANCE_ID" ]; then
            echo "Method 1 failed, trying method 2: network-interface filter..."
            INSTANCE_ID=$(aws ec2 describe-instances \
              --filters "Name=instance-state-name,Values=running" \
                        "Name=network-interface.association.public-ip,Values=${{ env.INSTANCE_IP }}" \
              --query 'Reservations[0].Instances[0].InstanceId' \
              --output text 2>/dev/null || echo "None")
          fi
          
          # Method 3: If still fails, search all running instances and match IP
          if [ "$INSTANCE_ID" = "None" ] || [ "$INSTANCE_ID" = "null" ] || [ -z "$INSTANCE_ID" ]; then
            echo "Method 2 failed, trying method 3: search all running instances..."
            INSTANCE_ID=$(aws ec2 describe-instances \
              --filters "Name=instance-state-name,Values=running" \
              --query "Reservations[].Instances[?PublicIpAddress=='${{ env.INSTANCE_IP }}'].InstanceId" \
              --output text 2>/dev/null || echo "None")
          fi
          
          if [ "$INSTANCE_ID" = "None" ] || [ "$INSTANCE_ID" = "null" ] || [ -z "$INSTANCE_ID" ]; then
            echo "âŒ Could not find running instance with IP ${{ env.INSTANCE_IP }}"
            echo "Available running instances:"
            aws ec2 describe-instances \
              --filters "Name=instance-state-name,Values=running" \
              --query 'Reservations[].Instances[].[InstanceId,PublicIpAddress,Tags[?Key==`Name`].Value|[0]]' \
              --output table || true
            exit 1
          fi
          
          echo "âœ… Found instance ID: $INSTANCE_ID"
          echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT

      # Check SSM agent status first
      - name: Check SSM Agent Status
        id: check-ssm
        run: |
          INSTANCE_ID="${{ steps.get-instance.outputs.instance_id }}"
          echo "ğŸ” Checking SSM agent status for instance: $INSTANCE_ID"
          
          # Check if instance is managed by SSM
          SSM_STATUS=$(aws ssm describe-instance-information \
            --filters "Key=InstanceIds,Values=$INSTANCE_ID" \
            --query 'InstanceInformationList[0].PingStatus' \
            --output text 2>/dev/null || echo "NotFound")
          
          echo "SSM Status: $SSM_STATUS"
          
          if [ "$SSM_STATUS" = "Online" ]; then
            echo "âœ… SSM agent is online and ready"
            echo "ssm_available=true" >> $GITHUB_OUTPUT
          else
            echo "âŒ SSM agent is not available or not configured"
            echo "This could be due to:"
            echo "1. SSM agent not installed or not running"
            echo "2. Instance missing required IAM role (AmazonSSMManagedInstanceCore)"
            echo "3. Security group not allowing outbound HTTPS (port 443)"
            echo "ssm_available=false" >> $GITHUB_OUTPUT
          fi

      # Step 4a: Deploy via Systems Manager (if available)
      - name: 4ï¸âƒ£a Deploy via Systems Manager
        if: steps.check-ssm.outputs.ssm_available == 'true'
        run: |
          echo "ğŸš€ Deploying to production server via AWS Systems Manager..."
          
          INSTANCE_ID="${{ steps.get-instance.outputs.instance_id }}"
          echo "Instance ID: $INSTANCE_ID"
          
          # Execute deployment via Systems Manager with direct commands
          echo "ğŸ”§ Executing deployment script via Systems Manager..."
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=[
              "echo \"ğŸ“¦ Starting deployment on server...\"",
              "cd /opt/book-review-api/current/backend 2>/dev/null || { echo \"Setting up fresh deployment...\"; sudo mkdir -p /opt/book-review-api; cd /opt/book-review-api; sudo git clone https://github.com/${{ github.repository }}.git current; cd current/backend; }",
              "echo \"ğŸ“¥ Pulling latest code...\"",
              "sudo git fetch origin",
              "sudo git reset --hard origin/main",
              "echo \"ğŸ—ï¸ Installing dependencies and building...\"",
              "sudo npm ci --only=production",
              "sudo npm run build",
              "echo \"ğŸ”„ Restarting application...\"",
              "sudo pkill -f \"node.*app.js\" 2>/dev/null || true",
              "sleep 3",
              "cd dist",
              "sudo nohup node app.js > /var/log/book-review-api.log 2>&1 &",
              "echo \"âœ… Deployment completed successfully\"",
              "sleep 2",
              "ps aux | grep \"node.*app.js\" | grep -v grep || echo \"Application process not found\""
            ]' \
            --query 'Command.CommandId' \
            --output text)
          
          echo "Command ID: $COMMAND_ID"
          
          # Wait for command completion
          echo "â³ Waiting for deployment to complete..."
          for i in {1..60}; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query 'Status' \
              --output text 2>/dev/null || echo "InProgress")
            
            echo "Status: $STATUS (attempt $i/60)"
            
            if [ "$STATUS" = "Success" ]; then
              echo "âœ… Deployment completed successfully!"
              break
            elif [ "$STATUS" = "Failed" ] || [ "$STATUS" = "Cancelled" ] || [ "$STATUS" = "TimedOut" ]; then
              echo "âŒ Deployment failed with status: $STATUS"
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --query 'StandardErrorContent' \
                --output text
              exit 1
            fi
            
            sleep 5
          done
          
          # Get command output
          echo "ğŸ“‹ Deployment output:"
          aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "$INSTANCE_ID" \
            --query 'StandardOutputContent' \
            --output text

      # Step 4b: Alternative deployment via webhook (if SSM not available)
      - name: 4ï¸âƒ£b Deploy via Webhook (Fallback)
        if: steps.check-ssm.outputs.ssm_available == 'false'
        run: |
          echo "ğŸ”„ SSM not available, using alternative deployment method..."
          echo "Setting up webhook-based deployment..."
          
          # Create a simple deployment webhook script
          cat > webhook-deploy.sh << 'EOF'
          #!/bin/bash
          # This script should be placed on your EC2 server and called via HTTP
          set -e
          
          echo "ğŸ“¦ Starting webhook deployment..."
          cd /opt/book-review-api/current/backend 2>/dev/null || {
            echo "Setting up fresh deployment..."
            sudo mkdir -p /opt/book-review-api
            cd /opt/book-review-api
            sudo git clone https://github.com/${{ github.repository }}.git current
            cd current/backend
          }
          
          echo "ğŸ“¥ Pulling latest code..."
          sudo git fetch origin
          sudo git reset --hard origin/main
          
          echo "ğŸ—ï¸ Installing dependencies and building..."
          sudo npm ci --only=production
          sudo npm run build
          
          echo "ğŸ”„ Restarting application..."
          sudo pkill -f "node.*app.js" 2>/dev/null || true
          sleep 3
          cd dist
          sudo nohup node app.js > /var/log/book-review-api.log 2>&1 &
          
          echo "âœ… Deployment completed successfully"
          EOF
          
          echo "ğŸ“‹ Alternative deployment options:"
          echo "1. **Manual SSH deployment:** Copy the webhook-deploy.sh script to your server and run it"
          echo "2. **Setup webhook endpoint:** Create a simple HTTP endpoint on your server that executes this script"
          echo "3. **Use GitHub webhook:** Configure GitHub to call your server directly on push"
          echo ""
          echo "ğŸ”§ To setup SSM for future deployments:"
          echo "1. Attach IAM role 'AmazonSSMManagedInstanceCore' to your EC2 instance"
          echo "2. Ensure SSM agent is installed and running"
          echo "3. Allow outbound HTTPS (port 443) in security group"
          echo ""
          echo "ğŸ“„ Deployment script content:"
          cat webhook-deploy.sh
          
          # Save deployment script for manual execution
          echo "ğŸ’¾ Saving deployment script for manual execution..."
          echo "To deploy manually, copy this script to your server and run it:"
          echo ""
          echo "# Copy the script to your server:"
          echo "scp webhook-deploy.sh ec2-user@${{ env.INSTANCE_IP }}:/tmp/"
          echo ""
          echo "# SSH to your server and run:"
          echo "ssh ec2-user@${{ env.INSTANCE_IP }}"
          echo "chmod +x /tmp/webhook-deploy.sh"
          echo "sudo /tmp/webhook-deploy.sh"
          echo ""
          echo "ğŸ”— Or run these commands directly on your server:"
          echo "cd /opt/book-review-api/current/backend && sudo git pull origin main && sudo npm run build && sudo pkill -f 'node.*app.js' && cd dist && sudo nohup node app.js > /var/log/book-review-api.log 2>&1 &"

      - name: Verify Deployment
        run: |
          echo "ğŸ” Verifying deployment..."
          sleep 15
          
          # Basic health check using HTTPS
          echo "Testing application endpoints..."
          
          # Try health endpoint with HTTPS
          if curl -f -k -m 10 https://${{ env.INSTANCE_IP }}/health 2>/dev/null; then
            echo "âœ… HTTPS Health check endpoint responded"
          elif curl -f -m 10 http://${{ env.INSTANCE_IP }}/health 2>/dev/null; then
            echo "âœ… HTTP Health check endpoint responded"
          else
            echo "âš ï¸ Health check endpoint not responding (may not be implemented)"
          fi
          
          # Try root endpoint
          if curl -f -k -m 10 https://${{ env.INSTANCE_IP }}/ 2>/dev/null; then
            echo "âœ… HTTPS Root endpoint responded"
          elif curl -f -m 10 http://${{ env.INSTANCE_IP }}/ 2>/dev/null; then
            echo "âœ… HTTP Root endpoint responded"
          else
            echo "âš ï¸ Root endpoint not responding"
          fi
          
          # Try API endpoint
          if curl -f -k -m 10 https://${{ env.INSTANCE_IP }}/api/v1/books 2>/dev/null; then
            echo "âœ… HTTPS API endpoint responded"
          elif curl -f -m 10 http://${{ env.INSTANCE_IP }}/api/v1/books 2>/dev/null; then
            echo "âœ… HTTP API endpoint responded"
          else
            echo "âš ï¸ API endpoint not responding"
          fi
          
          echo "ğŸ‰ Deployment pipeline completed!"
          echo "ğŸŒ Application should be running at: https://${{ env.INSTANCE_IP }}"
          echo "ğŸ”— Health check: https://${{ env.INSTANCE_IP }}/health"
          echo ""
          if [ "${{ steps.check-ssm.outputs.ssm_available }}" = "false" ]; then
            echo "ğŸ“‹ Manual deployment required - see deployment script above"
            echo "ğŸ’¡ To enable automatic deployment, configure AWS Systems Manager on your EC2 instance"
          fi
